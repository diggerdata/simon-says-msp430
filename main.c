#include <msp430.h>
#include <stdlib.h>
/* Peripherals.c and .h are where the functions that implement
 * the LEDs and keypad, etc are. It is often useful to organize
 * your code by putting like functions together in files.
 * You include the header associated with that file(s)
 * into the main file of your project. */
#include "peripherals.h"

// Function Prototypes
void startupScreen();
void countdown();
void playSequence();
void resetGame();
void watchSequence();
void swDelay(unsigned int numLoops);

// Declare globals here

// Initialize state to 0
unsigned int state = 0;
unsigned int round = 0;
// Create all the game colors
#define NUM_ROUNDS 32
unsigned int colors[32];

// *** Intro Screen ***


// Main
void main(void) {
    WDTCTL = WDTPW | WDTHOLD;
    // Useful code starts here
    unsigned char currKey=0, dispSz = 3;
    unsigned char dispThree[3];

    initLeds();
    configDisplay();
    configKeypad();
    Graphics_clearDisplay(&g_sContext); // Clear the display
    // We are now done writing to the display.  However, if we stopped here, we would not
    // see any changes on the actual LCD.  This is because we need to send our changes
    // to the LCD, which then refreshes the display.
    // Since this is a slow operation, it is best to refresh (or "flush") only after
    // we are done drawing everything we need.
//    Graphics_flushBuffer(&g_sContext);

    while (1)    // Forever loop
    {
        unsigned char currKey = getKey();
        switch(state) {
            case 0:
                startupScreen(); // Show startup screen
                break;
            case 1:
                resetGame();
                countdown(); // Show the countdown
                break;
            case 2:
                playSequence(); // Play the sequence
                break;
            case 3:
                watchSequence(); // Watch for user input
                break;
        }

        // Check if any keys have been pressed on the 3x4 keypad

        if (currKey == '*')
            state = 1; // Go to state 1 (countdown)
    }  // end while (1)
}

void startupScreen() {
//    setLeds(0x01);
//    Graphics_clearDisplay(&g_sContext); // Clear the display
    Graphics_drawStringCentered(&g_sContext, "ECE2049 SIMON", AUTO_STRING_LENGTH, 48, 15, TRANSPARENT_TEXT);
    Graphics_drawStringCentered(&g_sContext, "Press * to start", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
    Graphics_flushBuffer(&g_sContext);
}

void countdown() {
   Graphics_clearDisplay(&g_sContext); // Clear the display
   Graphics_drawStringCentered(&g_sContext, "3", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
   Graphics_flushBuffer(&g_sContext);
   swDelay(1000);
   Graphics_clearDisplay(&g_sContext);
   Graphics_drawStringCentered(&g_sContext, "2", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
   Graphics_flushBuffer(&g_sContext);
   swDelay(1000);
   Graphics_clearDisplay(&g_sContext);
   Graphics_drawStringCentered(&g_sContext, "1", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
   Graphics_flushBuffer(&g_sContext);
   swDelay(1000);
   Graphics_clearDisplay(&g_sContext);
   state = 2; // Set the state to 2 (playSequence)
}

void playSequence() {
//    unsigned int delay = 1000-(1000*(3*round)/124); // Delay that speeds up
    unsigned int delay = 1000;
    unsigned int i;
    for(i = 0; i <= round; i++) {
        switch(colors[i]) {
            case 0:
                setLeds(BIT1);
                Graphics_clearDisplay(&g_sContext); // Clear the display
                Graphics_drawStringCentered(&g_sContext, "1", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
                Graphics_flushBuffer(&g_sContext);
                BuzzerOn;
                swDelay(delay);
                setLeds(0);
                BuzzerOff;
                break;
            case 1:
                setLeds(BIT2);
                Graphics_clearDisplay(&g_sContext); // Clear the display
                Graphics_drawStringCentered(&g_sContext, "2", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
                Graphics_flushBuffer(&g_sContext);
                BuzzerOn;
                swDelay(delay);
                setLeds(0);
                BuzzerOff;
                break;
            case 2:
                setLeds(BIT3);
                Graphics_clearDisplay(&g_sContext); // Clear the display
                Graphics_drawStringCentered(&g_sContext, "3", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
                Graphics_flushBuffer(&g_sContext);
                BuzzerOn;
                swDelay(delay);
                setLeds(0);
                BuzzerOff;
                break;
            case 3:
                setLeds(BIT4);
                Graphics_clearDisplay(&g_sContext); // Clear the display
                Graphics_drawStringCentered(&g_sContext, "4", AUTO_STRING_LENGTH, 48, 25, TRANSPARENT_TEXT);
                Graphics_flushBuffer(&g_sContext);
                BuzzerOn;
                swDelay(delay);
                setLeds(0);
                BuzzerOff;
                break;
        }
    }
    state = 3; // Go to wait for input
}

void resetGame() {
    round = 0;
    unsigned int j;
    for (j = 0; j < 32; j++) {
        colors[j] = rand() % 4;
    }
}

void watchSequence() {
    volatile unsigned int inputNum = 0;
    unsigned char currKey = getKey();
    unsigned char lastKey = currKey;
    while(1) {
        currKey = getKey();
        unsigned int intKey = (currKey - '0') - 1;
        if(colors[inputNum] == intKey && currKey != lastKey) {
            if(round == inputNum) {
                state = 2;
                round++;
                break;
            }
            inputNum++;
        }
        else if(currKey != lastKey && colors[inputNum] != intKey) {
            state = 0;
            break;
        }
        lastKey = currKey;
    }
}


void swDelay(unsigned int numLoops)
{
	// This function is a software delay. It performs
	// useless loops to waste a bit of time
	//
	// Input: numLoops = number of delay loops to execute
	// Output: none
	//
	// smj, ECE2049, 25 Aug 2013

	volatile unsigned int i,j;	// volatile to prevent removal in optimization
			                    // by compiler. Functionally this is useless code

	for (j=0; j<numLoops; j++)
    {
    	i = 50 ;					// SW Delay
   	    while (i > 0)				// could also have used while (i)
	       i--;
    }
}
